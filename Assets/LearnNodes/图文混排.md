### å›¾æ–‡æ··æ’

#### æ€è€ƒ 

- #### æ€è€ƒä¸ºä»€ä¹ˆè¦ç”¨å›¾æ–‡æ··æ’ï¼Ÿ --- ä¸ºäº†èƒ½åœ¨æ–‡å­—ä¸­é—´ç©¿æ’å›¾ç‰‡ã€‚

- #### ç–‘é—®ï¼Œå› ä¸ºå›¾ç‰‡å’Œæ–‡å­—ä½¿ç”¨çš„ä¸æ˜¯åŒä¸€æè´¨ï¼Œæ€ä¹ˆæ ·å°†ä»–ä»¬ä½œä¸ºä¸€ä¸ªæ‰¹æ¬¡å»æ¸²æŸ“å‘¢ï¼Ÿ

- #### è®¾è®¡æ€è·¯ ï¼Œä¸ç®¡æ˜¯æ–‡å­—è¿˜æ˜¯å›¾ç‰‡æœ€ç»ˆåœ¨éƒ½æ˜¯å·²çº¹ç†çš„æ–¹å¼è¾“å…¥åˆ°gpuä¸­å»æ¸²æŸ“çš„ï¼Œå¯ä»¥ä½¿ç”¨MeshRenderå’ŒMeshFilterå°†å›¾ç‰‡å’Œæ–‡å­—åˆå¹¶åˆ°ä¸€ä¸ªMeshä¸Šå»æ¸²æŸ“ã€‚

- #### å‚è€ƒèµ„æ–™ https://zhuanlan.zhihu.com/p/30944504 ä¸€ä¸ªç³»åˆ—å‡ ç¯‡æè¿°äº†å¦‚ä½•å®ç°å›¾æ–‡æ··æ’ã€‚

  ------

  

  

- ###### ç¬¬ä¸€æ­¥æ˜ç™½ä¸€å¼ å›¾ç‰‡æ˜¯å¦‚æœè¢«æ˜¾ç¤ºå‡ºæ¥çš„ã€‚

  **åœ¨unityä¸­æ‰€æœ‰æ˜¾ç¤ºçš„å¯¹è±¡éƒ½æ˜¯æœ‰ä¸€ä¸ªä¸ªä¸‰è§’é¢æ„æˆçš„ï¼Œç„¶ååœ¨è¿™äº›ä¸‰è§’é¢ä¸Šè´´ä¸Šå„ç§å„æ ·çš„å›¾æ¡ˆï¼Œè¦æ¸²æŸ“ä¸€å¼ å›¾ç‰‡å°±è¦çŸ¥é“å›¾ç‰‡é•¿ä»€ä¹ˆæ ·å­ï¼ˆç½‘æ ¼ï¼‰ï¼Œå›¾ç‰‡å…·ä½“æ˜¾ç¤ºä»€ä¹ˆï¼ˆçº¹ç†æè´¨ï¼‰ï¼Œåœ¨unityä¸­ä½¿ç”¨renderç»„ä»¶å»å¤„ç†å¯¹è±¡æè´¨ä¿¡æ¯ï¼Œä½¿ç”¨meshfilterå»å¤„ç†ç½‘æ ¼ä¿¡æ¯ã€‚**

  **Unityä¸­ç»§æ‰¿äº†renderçš„ç»„ä»¶æœ‰MeshRender,SpriteRender,LineRenderç­‰ï¼Œå¤„ç†ç½‘æ ¼çš„æœ‰MeshFilter**

  **ç–‘é—®ğŸ¤”ï¸ï¼š2Dåªç”¨äº†spriterendererç»„ä»¶å°±å°†å›¾ç‰‡æ˜¾ç¤ºäº†å‡ºæ¥å®ƒæ˜¯æ€ä¹ˆåšåˆ°çš„ï¼ŸçŒœæµ‹spriterendererä¼šæ ¹æ®å›¾ç‰‡å¤§å°**

  å›ç­”ï¼š1.å°†å›¾ç‰‡å¯¼å…¥åˆ°unityæ—¶å¦‚æœä½œä¸ºSprite(2D and UI)å›¾ç‰‡æ ¼å¼æ—¶ï¼Œunityä¼šè‡ªåŠ¨ç»™è¿™äº›å›¾ç‰‡ç”Ÿæˆå¯¹åº”çš„ç½‘æ ¼ä¿¡æ¯ã€‚![image-20210812202856462](/Users/zhengzhengxu/Desktop/zhengxu/Unity3d/Tool/LearnNote/å›¾æ–‡æ··æ’.assets/image-20210812202856462.png)

  2.SpriteRendereré‡Œé¢å¯èƒ½ç›´æ¥è·å–äº†æ‰€ä½¿ç”¨çš„å›¾ç‰‡çš„ç½‘æ ¼æ•°æ®ã€‚

- å®ç°å›¾ç‰‡çš„æ˜¾ç¤º

  1.æ˜¾ç¤ºä¸€å¼ çº¯è‰²å›¾ç‰‡,ä¸€å¼ Meshæ‹¥æœ‰æ„æˆä¸‰è§’é¢çš„é¡¶ç‚¹æ•°æ®ï¼Œé¡¶ç‚¹ç»˜åˆ¶é¡ºåºï¼Œé¡¶ç‚¹é¢œè‰²ï¼Œuvåæ ‡è¿™å››ä¸ªåŸºæœ¬ä¿¡æ¯æ„æˆã€‚

  ```c#
  using UnityEngine;
  
  /// <summary>
  /// ç”»å‡ºä¸€å—é»‘è‰²å›¾
  /// </summary>
  public class Demo1 : MonoBehaviour
  {
      public int width = 512;
      public int height = 512;
      public Color color = Color.black;
  
      private MeshRenderer renderer;
      private MeshFilter filter;
      // Start is called before the first frame update
      void Start()
      {
          Shader s = Shader.Find("Unlit/ShaderDemo1");
          Material spMat = new Material(s);
  
          GameObject go = new GameObject("Demo1");
          renderer = go.AddComponent<MeshRenderer>();
          filter = go.AddComponent<MeshFilter>();
  
          renderer.sharedMaterial = spMat;
          Fill();
      }
  
      public void Fill()
      {
          Mesh mesh = new Mesh();
          filter.mesh = mesh;
          //è®¾ç½®é¡¶ç‚¹
          Vector3[] vertices = new Vector3[4];
          //è®¾ç½®ç‚¹é¡ºåº
          int[] triangles = new int[6];
          //è®¾ç½®é¢œè‰²
          Color[] colors = new Color[4];
          //è®¾ç½®uvåæ ‡
          Vector2[] uvs = new Vector2[4];
  
          float glWidth = (float)width / 2;
          float glHeight = (float)height / 2;
  
          //ä»¥å½“å‰å¯¹è±¡ä¸­å¿ƒç‚¹ä¸ºæ ‡å‡† å››ä¸ªé¡¶ç‚¹ æ„æˆ2ä¸ªä¸‰è§’é¢
          vertices[0] = new Vector3(-glWidth, -glHeight, 0);
          vertices[1] = new Vector3(-glWidth, glHeight, 0);
          vertices[2] = new Vector3(glWidth, -glHeight, 0);
          vertices[3] = new Vector3(glWidth, glHeight, 0);
  
          triangles[0] = 0;
          triangles[1] = 2;
          triangles[2] = 1;
          triangles[3] = 2;
          triangles[4] = 3;
          triangles[5] = 1;
  
          //è®¾ç½®é¡¶ç‚¹é¢œè‰²
          colors[0] = color;
          colors[1] = color;
          colors[2] = color;
          colors[3] = color;
  
          //ç»‘å®šuvåæ ‡
          uvs[0] = new Vector2(0, 0);
          uvs[1] = new Vector2(0, 1);
          uvs[2] = new Vector2(1, 0);
          uvs[3] = new Vector2(1, 1);
  
          mesh.vertices = vertices;
          mesh.triangles = triangles;
          mesh.colors = colors;
          mesh.uv = uvs;
      }
  
      /// <summary>
      /// ç›‘è§†é¢æ¿å€¼å‘ç°æ”¹å˜æ—¶è°ƒç”¨
      /// </summary>
      private void OnValidate()
      {
          if (filter && Application.isPlaying)
          {
              Fill();
          }
      }
  }
  ```

  ```c#
  Shader "Unlit/ShaderDemo1"
  {
    Properties
  	{
  		_MainTex ("Base (RGB), Alpha (A)", 2D) = "black" {}
  	}
  	
  	SubShader
  	{
  		LOD 200
  
  		Tags
  		{
  			"Queue" = "Transparent"
  			"IgnoreProjector" = "True"
  			"RenderType" = "Transparent"
  		}
  		
  		Pass
  		{
  			Cull Off
  			Lighting Off
  			ZWrite On
  			Fog { Mode Off }
  			Offset -1, -1
  			Blend SrcAlpha OneMinusSrcAlpha
  
  			CGPROGRAM
  			#pragma vertex vert
  			#pragma fragment frag			
  			#include "UnityCG.cginc"
  
  			sampler2D _MainTex;
  			float4 _MainTex_ST;
  	
  			struct appdata_t
  			{
  				float4 vertex : POSITION;
  				float2 texcoord : TEXCOORD0;
  				fixed4 color : COLOR;
  			};
  	
  			struct v2f
  			{
  				float4 vertex : SV_POSITION;
                  fixed color : COLOR;
  			};
  	
  			v2f o;
  
  			v2f vert (appdata_t v)
  			{
  				o.vertex = UnityObjectToClipPos(v.vertex);
                  o.color = v.color;
                  return o;
  			}
  				
  			fixed4 frag (v2f IN) : COLOR
  			{
  				 return IN.color;
  			}
  			ENDCG
  		}
  	}
  
  	//å¤‡èƒè®¾ä¸ºUnityè‡ªå¸¦çš„æ™®é€šæ¼«åå°„  
      Fallback" Diffuse "  
  }
  
  ```

- å›¾é›†æ˜¯æ€ä¹ˆè¿ä½œçš„ï¼Ÿä¸ºä»€ä¹ˆè¦æ‰“å›¾é›†ï¼Ÿ

  ä¸ºä»€ä¹ˆæ‰“å›¾é›†ä¸Šé¢ä»¥åŠè¯´è¿‡äº†ï¼Œå°±æ˜¯ä¸ºäº†ç¬¦åˆunityçš„æ‰¹æ¬¡åˆå¹¶ã€‚

  Meshæ ¹æ®è®¾ç½®uvä¿¡æ¯ä»å›¾é›†ä¸­è¯»å–å¯¹åº”ä½ç½®çš„åƒç´ ä¿¡æ¯ï¼Œä¸ç®¡ä¸€å¼ å¤šå¤§çš„å›¾å®ƒçš„uvå¤§å°éƒ½æ˜¯ä»0-1ï¼Œæˆ‘ä»¬åªéœ€è¦è®¾ç½®è¯»å–å“ªä¸€å—ä¿¡æ¯å³å¯ã€‚

  ```c#
  using UnityEngine;
  
  /// <summary>
  /// æ˜¾ç¤ºä¸€å¼ å›¾é›†çš„éƒ¨åˆ†æˆ–è€…å…¨éƒ¨ä¿¡æ¯
  /// </summary>
  public class Demo1 : MonoBehaviour
  {
      public int width = 512;
      public int height = 512;
      public Color color = Color.black;
  
      public Vector2 uv1 = new Vector2(0, 0);
      public Vector2 uv2 = new Vector2(0, 1);
      public Vector2 uv3 = new Vector2(1, 0);
      public Vector2 uv4 = new Vector2(1, 1);
      private MeshRenderer renderer;
      private MeshFilter filter;
      // Start is called before the first frame update
      void Start()
      {
          Shader s = Shader.Find("Unlit/ShaderDemo1");
          Material spMat = new Material(s);
  
          GameObject go = new GameObject("Demo1");
          renderer = go.AddComponent<MeshRenderer>();
          filter = go.AddComponent<MeshFilter>();
  
          renderer.sharedMaterial = spMat;
          Fill();
      }
  
      public void Fill()
      {
          Mesh mesh = new Mesh();
          filter.mesh = mesh;
          //è®¾ç½®é¡¶ç‚¹
          Vector3[] vertices = new Vector3[4];
          //è®¾ç½®ç‚¹é¡ºåº
          int[] triangles = new int[6];
          //è®¾ç½®é¢œè‰²
          Color[] colors = new Color[4];
          //è®¾ç½®uvåæ ‡
          Vector2[] uvs = new Vector2[4];
  
          float glWidth = (float)width / 2;
          float glHeight = (float)height / 2;
  
          //ä»¥å½“å‰å¯¹è±¡ä¸­å¿ƒç‚¹ä¸ºæ ‡å‡† å››ä¸ªé¡¶ç‚¹ æ„æˆ2ä¸ªä¸‰è§’é¢
          vertices[0] = new Vector3(-glWidth, -glHeight, 0);
          vertices[1] = new Vector3(-glWidth, glHeight, 0);
          vertices[2] = new Vector3(glWidth, -glHeight, 0);
          vertices[3] = new Vector3(glWidth, glHeight, 0);
  
          triangles[0] = 0;
          triangles[1] = 2;
          triangles[2] = 1;
          triangles[3] = 2;
          triangles[4] = 3;
          triangles[5] = 1;
  
          //è®¾ç½®é¡¶ç‚¹é¢œè‰²
          colors[0] = color;
          colors[1] = color;
          colors[2] = color;
          colors[3] = color;
  
          //ç»‘å®šuvåæ ‡
          uvs[0] = uv1;
          uvs[1] = uv2;
          uvs[2] = uv3;
          uvs[3] = uv4;
  
          mesh.vertices = vertices;
          mesh.triangles = triangles;
          mesh.colors = colors;
          mesh.uv = uvs;
      }
  
      /// <summary>
      /// ç›‘è§†é¢æ¿å€¼å‘ç°æ”¹å˜æ—¶è°ƒç”¨
      /// </summary>
      private void OnValidate()
      {
          if (filter && Application.isPlaying)
          {
              Fill();
          }
      }
  }
  ```

  ```c#
  Shader "Unlit/ShaderDemo1"
  {
    Properties
  	{
  		_MainTex ("Base (RGB), Alpha (A)", 2D) = "black" {}
  	}
  	
  	SubShader
  	{
  		LOD 200
  
  		Tags
  		{
  			"Queue" = "Transparent"
  			"IgnoreProjector" = "True"
  			"RenderType" = "Transparent"
  		}
  		
  		Pass
  		{
  			Cull Off
  			Lighting Off
  			ZWrite On
  			Fog { Mode Off }
  			Offset -1, -1
  			Blend SrcAlpha OneMinusSrcAlpha
  
  			CGPROGRAM
  			#pragma vertex vert
  			#pragma fragment frag			
  			#include "UnityCG.cginc"
  
  			sampler2D _MainTex;
  			float4 _MainTex_ST;
  	
  			struct appdata_t
  			{
  				float4 vertex : POSITION;
  				float2 texcoord : TEXCOORD0;
  				fixed4 color : COLOR;
  			};
  	
  			struct v2f
  			{
  				float4 vertex : SV_POSITION;
                  fixed color : COLOR;
                  float2 uv : TEXCOORD0;
  			};
  	
  			v2f o;
  
  			v2f vert (appdata_t v)
  			{
  				o.vertex = UnityObjectToClipPos(v.vertex);
                  o.color = v.color;
                  o.uv = TRANSFORM_TEX(v.texcoord, _MainTex);
                  return o;
  			}
  				
  			fixed4 frag (v2f IN) : COLOR
  			{
                   // tex2D å°±æ˜¯æ‹¿idå»æŸ¥è¯¢æ•°æ®è¡¨çš„å‡½æ•°
                   fixed4 color = tex2D(_MainTex,IN.uv) * IN.color;
  				 return color;
  			}
  			ENDCG
  		}
  	}
  
  	//å¤‡èƒè®¾ä¸ºUnityè‡ªå¸¦çš„æ™®é€šæ¼«åå°„  
      Fallback" Diffuse "  
  }
  
  ```

  **Test**

  å›¾é›†![image-20210816151700938](/Users/zhengzhengxu/Desktop/zhengxu/Unity3d/Tool/LearnNote/å›¾æ–‡æ··æ’.assets/image-20210816151700938.png)

  å½“æˆ‘è®¾ç½®è¯»å–ä¸€å¼ è´´å›¾çš„å…¨éƒ¨ä¿¡æ¯æ—¶ï¼Œåªéœ€è¦è®¾ç½®4ä¸ªç‚¹çš„uvåæ ‡å¯¹åº”çš„ä¸ºå·¦ä¸‹ï¼ˆ0ï¼Œ0ï¼‰å·¦ä¸Šï¼ˆ0ï¼Œ1ï¼‰å³ä¸‹ï¼ˆ1ï¼Œ0ï¼‰å³ä¸Šï¼ˆ1ï¼Œ1ï¼‰å³å¯ã€‚

  ![image-20210816151504995](/Users/zhengzhengxu/Desktop/zhengxu/Unity3d/Tool/LearnNote/å›¾æ–‡æ··æ’.assets/image-20210816151504995.png)

   

å½“æˆ‘è®¾ç½®ï¼ˆ0ï¼Œ0ï¼‰ï¼ˆ0ï¼Œ0.5ï¼‰ï¼ˆ1ï¼Œ0ï¼‰ï¼Œï¼ˆ1ï¼Œ0.5ï¼‰æ—¶

![image-20210816151725677](/Users/zhengzhengxu/Desktop/zhengxu/Unity3d/Tool/LearnNote/å›¾æ–‡æ··æ’.assets/image-20210816151725677.png)

åªæ˜¾ç¤ºäº†ä¸‹åŠéƒ¨åˆ†çš„ä¿¡æ¯ã€‚

- è‡ªå®šä¹‰å›¾é›†ç±»ï¼Œä»æ ¹æœ¬ä¸Šäº†è§£å›¾é›†æ˜¯æ€ä¹ˆä½¿ç”¨çš„.

  - é¦–å…ˆéœ€è¦çŸ¥é“å›¾é›†çš„ä¿¡æ¯ï¼Œå›¾é›†ä¿¡æ¯æ˜¯ç”±ä¸€å¼ ä¸€å¼ çš„å›¾ç‰‡ä¿¡æ¯æ„æˆï¼Œå›¾ç‰‡æ•°æ®æœ‰**å›¾ç‰‡åœ¨æ‰“å…¥å›¾é›†å‰çš„åç§°**ï¼Œ**å›¾ç‰‡åœ¨å›¾é›†ä¸­çš„x yåƒç´ åæ ‡**ï¼Œ**å›¾ç‰‡åƒç´ å®½é«˜** è¿™å‡ ç§ä¿¡æ¯æ„æˆã€‚

    ```json
    {"frames": {
    
    "000.png":
    {
    	"frame": {"x":1,"y":1,"w":64,"h":64},
    	"rotated": false,
    	"trimmed": false,
    	"spriteSourceSize": {"x":0,"y":0,"w":64,"h":64},
    	"sourceSize": {"w":64,"h":64}
    },
    "001.png":
    {
    	"frame": {"x":67,"y":1,"w":64,"h":64},
    	"rotated": false,
    	"trimmed": false,
    	"spriteSourceSize": {"x":0,"y":0,"w":64,"h":64},
    	"sourceSize": {"w":64,"h":64}
    }},
    "meta": {
    	"app": "http://www.codeandweb.com/texturepacker",
    	"version": "1.0",
    	"image": "emoji.png",
    	"format": "RGBA8888",
    	"size": {"w":132,"h":66},
    	"scale": "1",
    	"smartupdate": "$TexturePacker:SmartUpdate:92bc191af69be79a384fd922753ed6c5:25e99f65893a681b9451ccea0e1d2668:8adc12750d6a6de2598ddc2744d97dab$"
    }
    }
    
    ```

  - å›¾é›†ä¸­å›¾åƒæ•°æ®åºåˆ—åŒ–ç±»ï¼Œå°†ä¸Šé¢çš„å•ä¸ªå›¾åƒæ•°æ®è½¬æ¢ä¸ºc#æ•°æ®ç±»ã€‚

    ```c#
    using UnityEngine;
    
    /// <summary>
    /// åºåˆ—åŒ–å›¾é›†æ•°æ®
    /// </summary>
    [System.Serializable]
    public class MySpriteData 
    {
        public string name = "Sprite";
    
        public int x = 0;
        public int y = 0;
        public int width = 0;
        public int height = 0;
        //å·¦è¾¹
        public int borderLeft = 0;
        //å³è¾¹
        public int borderRight = 0;
        //ä¸Šè¾¹
        public int borderTop = 0;
        //ä¸‹è¾¹
        public int borderBottom = 0;
    
        //ä¸Šä¸‹å·¦å³é—´éš”åƒç´ 
        public int paddingLeft = 0;
        public int paddingRight = 0;
        public int paddingTop = 0;
        public int paddingBottom = 0;
        /// <summary>
        /// æ˜¯å¦æ”¯æŒæ—‹è½¬
        /// </summary>
        public bool rotated = false;
    
        //è½¬UVåæ ‡
        static public Rect ConvertToTexCoords(Rect rect, int width, int height)
        {
            Rect final = rect;
            //uvå¤§å°æ˜¯ä»0-1ï¼Œè®¡ç®—å‡ºå›¾ç‰‡åœ¨å›¾é›†ä¸­æ‰€å çš„çŸ©å½¢å¤§å°
            if (width != 0f && height != 0f)
            {
                //xèµ·å§‹ä½ç½®
                final.xMin = rect.xMin / width;
                //xæœ«ç«¯ä½ç½®
                final.xMax = rect.xMax / width;
                //yèµ·å§‹ä½ç½®  
                final.yMin = 1f - rect.yMax / height;
                //yæœ«ç«¯ä½ç½®
                final.yMax = 1f - rect.yMin / height;
            }
            return final;
        }
    }
    ```

  - å›¾é›†ååºåˆ—åŒ–ç±»

    ```c#
    using System;
    using System.Collections;
    using System.Collections.Generic;
    using UnityEditor;
    using UnityEngine;
    [CustomEditor(typeof(MyAltas))]
    public class MyAtlasInspector : Editor
    {
        //éœ€è¦åˆå§‹åŒ–çš„å›¾é›†ç±»
        MyAltas mAtlas;
    
        public override void OnInspectorGUI()
        {
            //å°†å½“å‰å¯¹åº”è½¬æ¢ä¸ºMyAltasèµ„æº
            mAtlas = target as MyAltas;
            //è·å–æè´¨
            mAtlas.spriteMaterial = EditorGUILayout.ObjectField("material", mAtlas.spriteMaterial, typeof(Material), true) as Material;
            
            TextAsset ta = EditorGUILayout.ObjectField("TP Import", null, typeof(TextAsset), false) as TextAsset;
            if (ta != null)
            {
                LoadSpriteData(mAtlas, ta);
            }
        }
    
        static public void LoadSpriteData(MyAltas atlas, TextAsset asset)
        {
            if (asset == null || atlas == null) return;
    
            string jsonString = asset.text;
            Hashtable decodedHash = MyJson.jsonDecode(jsonString) as Hashtable;
    
            if (decodedHash == null)
            {
                Debug.LogWarning("Unable to parse Json file: " + asset.name);
            }
            else
            {
                LoadSpriteData(atlas, decodedHash);
            }
    
            asset = null;
            Resources.UnloadUnusedAssets();
        }
    
        /// <summary>
        /// Parse the specified JSon file, loading sprite information for the specified atlas.
        /// </summary>
    
        static void LoadSpriteData(MyAltas atlas, Hashtable decodedHash)
        {
            if (decodedHash == null || atlas == null) return;
            List<MySpriteData> oldSprites = atlas.spriteList;
            atlas.spriteList = new List<MySpriteData>();
    
            Hashtable frames = (Hashtable)decodedHash["frames"];
    
            foreach (DictionaryEntry item in frames)
            {
                MySpriteData newSprite = new MySpriteData();
                newSprite.name = item.Key.ToString();
    
                bool exists = false;
    
                // Check to see if this sprite exists
                foreach (MySpriteData oldSprite in oldSprites)
                {
                    if (oldSprite.name.Equals(newSprite.name, StringComparison.OrdinalIgnoreCase))
                    {
                        exists = true;
                        break;
                    }
                }
    
                // Get rid of the extension if the sprite doesn't exist
                // The extension is kept for backwards compatibility so it's still possible to update older atlases.
                if (!exists)
                {
                    newSprite.name = newSprite.name.Replace(".png", "");
                    newSprite.name = newSprite.name.Replace(".tga", "");
                }
    
                // Extract the info we need from the TexturePacker json file, mainly uvRect and size
                Hashtable table = (Hashtable)item.Value;
                Hashtable frame = (Hashtable)table["frame"];
    
                int frameX = int.Parse(frame["x"].ToString());
                int frameY = int.Parse(frame["y"].ToString());
                int frameW = int.Parse(frame["w"].ToString());
                int frameH = int.Parse(frame["h"].ToString());
    
                // Read the rotation value
                newSprite.rotated = (bool)table["rotated"];
    
                newSprite.x = frameX;
                newSprite.y = frameY;
                newSprite.width = frameW;
                newSprite.height = frameH;
    
                // Support for trimmed sprites
                Hashtable sourceSize = (Hashtable)table["sourceSize"];
                Hashtable spriteSize = (Hashtable)table["spriteSourceSize"];
    
                if (spriteSize != null && sourceSize != null)
                {
                    // TODO: Account for rotated sprites
                    if (frameW > 0)
                    {
                        int spriteX = int.Parse(spriteSize["x"].ToString());
                        int spriteW = int.Parse(spriteSize["w"].ToString());
                        int sourceW = int.Parse(sourceSize["w"].ToString());
    
                        newSprite.paddingLeft = spriteX;
                        newSprite.paddingRight = sourceW - (spriteX + spriteW);
                    }
    
                    if (frameH > 0)
                    {
                        int spriteY = int.Parse(spriteSize["y"].ToString());
                        int spriteH = int.Parse(spriteSize["h"].ToString());
                        int sourceH = int.Parse(sourceSize["h"].ToString());
    
                        newSprite.paddingTop = spriteY;
                        newSprite.paddingBottom = sourceH - (spriteY + spriteH);
                    }
                }
    
                // [Modify] by maosongliang, begin
                if (newSprite.rotated)
                {
                    int temp = newSprite.width;
                    newSprite.width = newSprite.height;
                    newSprite.height = temp;
    
                    temp = newSprite.paddingLeft;
                    newSprite.paddingLeft = newSprite.paddingTop;
                    newSprite.paddingTop = temp;
    
                    temp = newSprite.paddingRight;
                    newSprite.paddingRight = newSprite.paddingBottom;
                    newSprite.paddingBottom = temp;
                }
                // [Modify] by maosongliang, end
    
                // If the sprite was present before, see if we can copy its inner rect
                foreach (MySpriteData oldSprite in oldSprites)
                {
                    if (oldSprite.name.Equals(newSprite.name, StringComparison.OrdinalIgnoreCase))
                    {
                        if (oldSprite.rotated != newSprite.rotated)
                        {
                            // ---modify=> by zengyi
    
                            // left top changed
                            if (oldSprite.rotated)
                            {
                                newSprite.borderLeft = oldSprite.borderTop;
                                newSprite.borderTop = oldSprite.borderRight;
                                newSprite.borderBottom = oldSprite.borderLeft;
                                newSprite.borderRight = oldSprite.borderBottom;
                            }
                            else
                            {
                                newSprite.borderLeft = oldSprite.borderTop;
                                newSprite.borderTop = oldSprite.borderLeft;
                                // right bottom changed
                                newSprite.borderRight = oldSprite.borderBottom;
                                newSprite.borderBottom = oldSprite.borderRight;
                            }
    
                            //-----------------------
                        }
                        else
                        {
                            newSprite.borderLeft = oldSprite.borderLeft;
                            newSprite.borderRight = oldSprite.borderRight;
                            newSprite.borderBottom = oldSprite.borderBottom;
                            newSprite.borderTop = oldSprite.borderTop;
                        }
    
                        break;
                    }
                }
    
                // Add this new sprite
                atlas.spriteList.Add(newSprite);
            }
    
            // Sort imported sprites alphabetically
            atlas.spriteList.Sort(CompareSprites);
            Debug.Log("Imported " + atlas.spriteList.Count + " sprites");
        }
    
        /// <summary>
        /// Sprite comparison function for sorting.
        /// </summary>
    
        static int CompareSprites(MySpriteData a, MySpriteData b) { return a.name.CompareTo(b.name); }
    } 
    ```

    

  - å›¾é›†æ•°æ®ç±»ï¼Œé‡Œé¢å­˜å‚¨ç€æ‰€æœ‰å·²ååºåˆ—åŒ–åçš„å›¾ç‰‡æ•°æ®

    ```c#
    using System.Collections.Generic;
    using UnityEngine;
    public class MyAtlas : MonoBehaviour
    {
        //spriteä½¿ç”¨çš„æè´¨ï¼Œæè´¨å¼•ç”¨äº†å½“å‰éœ€è¦ä½¿ç”¨çš„å›¾é›†
        [SerializeField]
        public Material spriteMaterial;
        //å›¾ç‰‡æ•°æ®åˆ—è¡¨ ååºåˆ—åŒ–ä¸æ”¯æŒå­—å…¸ æ‰€ä»¥ä½¿ç”¨åˆ—è¡¨å…ˆä¿å­˜ï¼Œç„¶åé€šè¿‡å­—å…¸å»å¿«é€ŸæŸ¥è¯¢è·å–
        [SerializeField]
        private List<MySpriteData> m_sprites = new List<MySpriteData>();
        //å­—å…¸
        [System.NonSerialized]
        private Dictionary<string, MySpriteData> m_spritesDict = new Dictionary<string, MySpriteData>();
        //æ˜¯å¦åˆå§‹åŒ–
        [System.NonSerialized]
        private bool m_inited = false;
    
        public List<MySpriteData> spriteList
        {
            get
            {
                return m_sprites;
            }
            set
            {
                m_sprites = value;
            }
        }
        
        //æ ¹æ®åç§°è·å–å¯¹åº”çš„å›¾ç‰‡æ•°æ®
        public MySpriteData GetSpriteDataByName(string name)
        {
            MySpriteData result = null;
    
            if (!m_inited)
            {
                SlotDictData();
            }
            m_spritesDict.TryGetValue(name, out result);
            return result;
        }
        
        //åˆå§‹åŒ–æ•°æ®
        public void SlotDictData()
        {
            if (m_inited) return;
    
            for (int i = 0, imax = m_sprites.Count; i < imax; i++)
            {
                MySpriteData data = m_sprites[i];
                m_spritesDict[data.name] = data;
            }
    
            m_inited = true;
        }
    }
    
    ```

  - æ ¹æ®å›¾ç‰‡åç§°è·å–å›¾ç‰‡æ•°æ®ï¼Œæ ¹æ®å›¾ç‰‡æ•°æ®è®¡ç®—å‡ºå›¾ç‰‡åœ¨å›¾é›†ä¸­çš„uvä¿¡æ¯ï¼Œè®¾ç½®meshçš„æè´¨ä½¿ç”¨çº¹ç†ä¸ºå›¾é›†çº¹ç†ï¼Œè®¾ç½®meshçš„uvåæ ‡ä¸ºå¯¹åº”çš„å›¾ç‰‡uvåæ ‡ã€‚

    ```c#
    using System.Collections.Generic;
    using UnityEngine;
    
    public class MySprite : MonoBehaviour
    {
        public int width = 220;
        public int height = 102;
        //å›¾é›†èµ„æº
        public MyAltas atlas;
        //å›¾ç‰‡åç§°
        public string spriteName = "cancel";
        //å½“å‰å›¾ç‰‡ä¿¡æ¯
        private MySpriteData m_sprite;
    
        private MeshFilter meshFilter;
        private MeshRenderer meshRenderer;
        //æ”¯æŒå›¾ç‰‡æ—‹è½¬çš„å›¾é›†éœ€è¦ä½¿ç”¨
        Rect m_innerUV = new Rect();
        //å›¾ç‰‡uvä¿¡æ¯
        Rect m_outerUV = new Rect();
        const int maxIndexBufferCache = 10;
        static List<int[]> mCache = new List<int[]>(maxIndexBufferCache);
        
        //é¡¶ç‚¹ uvåæ ‡
        List<Vector3> vertices = new List<Vector3>();
        List<Vector2> uv = new List<Vector2>();
        //å›¾ç‰‡ä¸Šä¸‹å·¦å³uvåæ ‡ç‚¹
        Vector4 drawingUVs
        {
            get
            {
                return new Vector4(m_outerUV.xMin, m_outerUV.yMin, m_outerUV.xMax, m_outerUV.yMax);
            }
        }
        
        Vector4 drawingDimensions
        {
            get
            {
                float halfWidth = 0.5f * width;
                float halfHeight = 0.5f * height;
    
                return new Vector4(-halfWidth, -halfHeight, halfWidth, halfHeight);
            }
        }
    
        void Start()
        {
            //å¾—åˆ°MeshFilterå¯¹è±¡//  
            meshFilter = gameObject.GetComponent<MeshFilter>();
            meshRenderer = null;
            if (meshFilter == null)
            {
                //ä¸ºnullæ—¶ï¼Œè‡ªåŠ¨æ·»åŠ //  
                meshFilter = gameObject.AddComponent<MeshFilter>();
                meshRenderer = gameObject.AddComponent<MeshRenderer>();
                if (atlas != null)
                {
                    meshRenderer.sharedMaterial = atlas.spriteMaterial;
                }
            }
            Fill();
        }
    
        void OnValidate()
        {
            if (meshFilter && Application.isPlaying)
            {
                Fill();
            }
        }
    
        void Fill()
        {
            if (atlas == null) return;
            if (string.IsNullOrEmpty(spriteName)) return;
            m_sprite = atlas.GetSpriteDataByName(spriteName);
    
            CalUV();
    
            Vector4 u = drawingUVs;
            Vector4 v = drawingDimensions;
    
            //å¾—åˆ°å¯¹åº”çš„ç½‘æ ¼å¯¹è±¡//  
            Mesh mesh = new Mesh();
            meshFilter.mesh = mesh;
    
            //ä¸‰è§’å½¢é¡¶ç‚¹çš„åæ ‡æ•°ç»„//  
            vertices.Clear();
            //uvè´´å›¾åæ ‡//
            uv.Clear();
    
            //ä¸‰è§’å½¢é¡¶ç‚¹æ•°ç»„//  
            int[] triangles = GenerateCachedIndexBuffer(4, 6);
            //é¢œè‰²æ•°ç»„//
            Color[] colors = new Color[4];
    
            vertices.Add(new Vector3(v.x, v.y, 0));
            vertices.Add(new Vector3(v.x, v.w, 0));
            vertices.Add(new Vector3(v.z, v.w, 0));
            vertices.Add(new Vector3(v.z, v.y, 0));
    
            //è®¾ç½®é¡¶ç‚¹é¢œè‰²//
            colors[0] = Color.white;
            colors[1] = Color.white;
            colors[2] = Color.white;
            colors[3] = Color.white;
    
            //ç»‘å®šè´´å›¾UV//
            uv.Add(new Vector2(u.x, u.y));
            uv.Add(new Vector2(u.x, u.w));
            uv.Add(new Vector2(u.z, u.w));
            uv.Add(new Vector2(u.z, u.y));
    
    
            //ç»™meshèµ‹å€¼//
            mesh.SetVertices(vertices);
            mesh.triangles = triangles;
            mesh.colors = colors;
            mesh.SetUVs(0, uv);
        }
        //æ ¹æ®é¡¶ç‚¹è·å–æ„æˆä¸‰è§’é¢é¡ºåº æœ‰ç¼“å­˜çš„ä¿¡æ¯åˆ™ç›´æ¥ä½¿ç”¨ç¼“å­˜çš„
        protected int[] GenerateCachedIndexBuffer(int vertexCount, int indexCount)
        {
            for (int i = 0, imax = mCache.Count; i < imax; ++i)
            {
                int[] ids = mCache[i];
                if (ids != null && ids.Length == indexCount)
                    return ids;
            }
    
            int[] rv = new int[indexCount];
            int index = 0;
    
            for (int i = 0; i < vertexCount; i += 4)
            {
                rv[index++] = i;
                rv[index++] = i + 1;
                rv[index++] = i + 2;
    
                rv[index++] = i + 2;
                rv[index++] = i + 3;
                rv[index++] = i + 0;
            }
    
            if (mCache.Count > maxIndexBufferCache) mCache.RemoveAt(0);
            mCache.Add(rv);
            return rv;
        }
    
        //è®¡ç®—uvä¿¡æ¯
        private void CalUV()
        {
            Rect outer = new Rect(m_sprite.x, m_sprite.y, m_sprite.width, m_sprite.height);
            //åªæœ‰å›¾é›†æ”¯æŒæ—‹è½¬å›¾ç‰‡åˆå›¾æ—¶æ‰ç”¨çš„åˆ°
            Rect inner = new Rect(m_sprite.x + m_sprite.borderLeft, m_sprite.y + m_sprite.borderTop,
                m_sprite.width - m_sprite.borderLeft - m_sprite.borderRight,
                m_sprite.height - m_sprite.borderBottom - m_sprite.borderTop);
            //æ ¹æ®æè´¨å¼•ç”¨çš„çº¹ç†å®½é«˜ï¼Œè®¡ç®—å‡ºå½“å‰å›¾ç‰‡åœ¨å›¾é›†ä¸­çš„uvä¿¡æ¯
            Texture tex = atlas.spriteMaterial.mainTexture;
            m_outerUV = MySpriteData.ConvertToTexCoords(outer, tex.width, tex.height);
            m_innerUV = MySpriteData.ConvertToTexCoords(inner, tex.width, tex.height);
        }
    }
    ```
  
- **æ–‡å­—ç±»çš„å®ç°ï¼Œå’Œå›¾ç‰‡æ˜¾ç¤ºç±»ä¼¼ï¼Œä½¿ç”¨unity apiä»å­—ä½“èµ„æºä¸­è¯»å–å¯¹åº”å­—ç¬¦çš„uvï¼Œå­—ç¬¦ä¸²å°±æ˜¯nä¸ªå­—ç¬¦çš„ä¿¡æ¯æ‹¼æ¥åœ¨ä¸€èµ·**

- https://docs.unity3d.com/ScriptReference/Font.RequestCharactersInTexture.html å®˜æ–¹æ–‡æ¡£

  ```c#
  using UnityEngine;
  using System.Collections.Generic;
  
  public class TestFont : MonoBehaviour
  {
      //æ–‡å­—èµ„æº
      public Font font;
      //æ–‡å­—
      public string str = "Hello World";
      public int fontSize = 40;
      public float outWidth = 5;
      public Color fontColor = Color.white;
      public Color outColor = Color.black;
      Mesh mesh;
  
      void OnFontTextureRebuilt(Font changedFont)
      {
          if (changedFont != font)
              return;
  
          RebuildMesh();
      }
  
      void OnValidate() {
          if (!Application.isPlaying) return;
          RebuildMesh();
      }
  
      void RebuildMesh()
      {
          if (mesh == null) return;
          //ä½¿ç”¨unity api è¯·æ±‚å°†å­—ç¬¦æ·»åŠ åˆ°å­—ä½“çº¹ç†
          font.RequestCharactersInTexture(str, fontSize);
          mesh.Clear();
          // Generate a mesh for the characters we want to print.
          List<Vector3> vertices = new List<Vector3>();
          List<int> triangles = new List<int>();
          List<Vector2> uv = new List<Vector2>();
          List<Color> color = new List<Color>();
  
          //è¿™é‡Œæ˜¯æè¾¹
          DrawText(vertices, triangles, uv, color, outColor, new Vector3(outWidth,0,0), 0);
          DrawText(vertices, triangles, uv, color, outColor, new Vector3(-outWidth,0,0), 1);
          DrawText(vertices, triangles, uv, color, outColor, new Vector3(0, outWidth, 0), 2);
          DrawText(vertices, triangles, uv, color, outColor, new Vector3(0, -outWidth, 0), 3);
          DrawText(vertices, triangles, uv, color, outColor, new Vector3(outWidth, outWidth, 0), 4);
          DrawText(vertices, triangles, uv, color, outColor, new Vector3(outWidth, -outWidth, 0), 5);
          DrawText(vertices, triangles, uv, color, outColor, new Vector3(-outWidth, outWidth, 0), 6);
          DrawText(vertices, triangles, uv, color, outColor, new Vector3(-outWidth, -outWidth, 0), 7);
  
          //è¿™é‡Œæ˜¯çœŸæ­£çš„å­—
          DrawText(vertices, triangles, uv, color, fontColor, Vector3.zero, 8);
  
          mesh.vertices = vertices.ToArray();
          mesh.triangles = triangles.ToArray();
          mesh.uv = uv.ToArray();
          mesh.colors = color.ToArray();
      }
      //ç»˜åˆ¶
      void DrawText(List<Vector3> vertices, List<int> triangles, List<Vector2> uv, List<Color> colorList, Color color, Vector3 offset, int index) {
  
          Vector3 pos = Vector3.zero - offset;
          font.RequestCharactersInTexture(str, fontSize);
          for (int i = 0; i < str.Length; i++)
          {
              // ä»å­—ä½“ä¸­è·å–å­—ç¬¦æ¸²æŸ“ä¿¡æ¯
              CharacterInfo ch;
              font.GetCharacterInfo(str[i], out ch, fontSize);
              //é¡¶ç‚¹ä¿¡æ¯ æ¯ä¸ªå­—ç¬¦æœ‰xåç§»
              vertices.Add(pos + new Vector3(ch.minX, ch.maxY, 0));
              vertices.Add(pos + new Vector3(ch.maxX, ch.maxY, 0));
              vertices.Add(pos + new Vector3(ch.maxX, ch.minY, 0));
              vertices.Add(pos + new Vector3(ch.minX, ch.minY, 0));
  
              colorList.Add(color);
              colorList.Add(color);
              colorList.Add(color);
              colorList.Add(color);
              //å­—ä½“uv
              uv.Add(ch.uvTopLeft);
              uv.Add(ch.uvTopRight);
              uv.Add(ch.uvBottomRight);
              uv.Add(ch.uvBottomLeft);
  
              triangles.Add(4 * (i + index * str.Length) + 0);
              triangles.Add(4 * (i + index * str.Length) + 1);
              triangles.Add(4 * (i + index * str.Length) + 2);
  
              triangles.Add(4 * (i + index * str.Length) + 0);
              triangles.Add(4 * (i + index * str.Length) + 2);
              triangles.Add(4 * (i + index * str.Length) + 3);
  
              // å­—ç¬¦ä¹‹é—´çš„åç§»åæ ‡ xè½´ä¸Š
              pos += new Vector3(ch.advance, 0, 0);
          }
      }
  
      void Start()
      {
          //font = Font.CreateDynamicFontFromOSFont("Helvetica", 16);
          // Set the rebuild callback so that the mesh is regenerated on font changes.
          Font.textureRebuilt += OnFontTextureRebuilt;
  
          // Set up mesh.
          mesh = new Mesh();
          GetComponent<MeshFilter>().mesh = mesh;
          GetComponent<MeshRenderer>().material = font.material;
  
          // Generate font mesh.
          RebuildMesh();
      }
  
      void OnDestroy()
      {
          Font.textureRebuilt -= OnFontTextureRebuilt;
      }
  }
  ```

- å›¾æ–‡æ··æ’ï¼Œä¸Šé¢å®ç°äº†å›¾ç‰‡çš„æ˜¾ç¤ºå’Œæ–‡å­—çš„æ˜¾ç¤ºï¼Œæ€ä¹ˆè®²å›¾ç‰‡å’Œæ–‡å­—ä¸€èµ·æ˜¾ç¤ºå‘¢ï¼Ÿ

  **ä½¿ç”¨çº¦å®šå¥½çš„æ–‡æœ¬è§£æè§„åˆ™ï¼Œå¦‚æœé‡åˆ°æ˜¯å›¾ç‰‡è§„åˆ™çš„æ–‡æœ¬åˆ™è§£æå›¾ç‰‡uvä¿¡æ¯ï¼Œå¦‚æœæ˜¯æ–‡å­—åˆ™è§£ææ–‡å­—uvä¿¡æ¯ï¼Œå°†è¿™äº›ä¿¡æ¯è®¾ç½®åˆ°ä¸€ä¸ªmeshä¸­ï¼Œå›¾ç‰‡uvä½¿ç”¨uv1æ–‡æœ¬ä½¿ç”¨uv2**

  ```c#
  //TODO:
  ```

  

