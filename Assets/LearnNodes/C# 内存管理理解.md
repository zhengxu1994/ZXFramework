# C# 内存管理理解

#### C# 内存分别存放在一个叫栈,一个叫堆的地方

#### 栈中存放的是一些值类型变量和引用类型的引用地

**tip:这里将值类型变量和引用地址都叫做值类型**

*栈严格遵循先进后出的模式，当一个方法结束后会将方法内使用的临时值类型变量出栈操作，如果方法中调用了其他方法，也会等调用的方法先出栈，在返回原来的方法进行出栈*

```c#
public class Test
{
   public int aa = 5;//这边值类型并不在栈中，因为它是属于这个类的，而类是引用类型，存放在堆中的
   public void Test1()
   {
     {
       int d = 20;
     }//在这个大括号结束后就会把d给释放掉 所以下面无法引用到d
      int a = 5;
      int b = 10;
      int c = 11;
     //出栈顺序就是11 -- 10 -- 5
      Test2();//如果新调用了一个test2方法，那么出栈顺序就变成了 ccc -- bbb --- aaa - c - b - a
   }  
  
   public void Test2()
   {
      int aaa = 5;
      int bbb = 10;
      int ccc = 11;
   }
}
```



#### 堆中存放的就是一些引用类型，栈中的地址指向了这些堆内存中的对象。

**在没有GC垃圾回收机制时，所有的堆对象都需要手动释放（如果不手动释放就会造成内存泄露哦），当需要一块内存时，系统就会寻找是否有被释放的合适大小的内存块进行复用（copy过去），如果没有则会在栈顶开辟一块新的内存用于存放对象。**

**在一些新的高级语言中，都实现了一种GC垃圾回收机制，GC会在某个时刻被触发（一段时间或者内存不够时）,GC会搜索堆内存中没有被任何对象引用的内存进行释放，并整合，整合就是把所有的没有被释放的内存向栈底copy，这种操作会让对象的内存地址发生改变，所以在GC的时候会暂停所有的线程，将对象的引用地址指向移动后的新地址。**

```c#
public class Test
{
  public void Test()
  {
    var l = new List<int>(){1,2,3,4};//list 4个int 不考虑list内部开辟新内存的倍数
    var s = new List<int>();
    l.Add(5);//这时发现l的内存不足以存放5 l的前面又又一个s，所以他们又不是连续，就需要将开辟一块新的内存，将lcopy过去，原来的l内存将会被回收。
  }//如果l  s没有被其他地方引用，那么在这个方法结束就会被释放，内存等待回收。
}
```

