   ### 寻路算法

- 初级 AStar算法

  - AStar算法核心，A*算法特点是能够选择出一条最优解，缺点也很明显那就是广度算法它会讲周围所有的点都遍历一片，这些点中有很多点是不需要参与计算的。

    - f  = g + h 即 g(n)是节点n距离起点的距离 h(n)是节点距离终点的预计代价。

    - ```C#
      using Bepop.Core;
      using System;
      using System.Collections;
      using System.Collections.Generic;
      using UnityEngine;
      
      public class AStarManager : Singleton<AStarManager>
      {
      
      }
      
      public class AStarNode
      {
          public int x;
          public int y;
          public bool isObstacle;
      
          public AStarNode parent = null;
      
          public int  g, h;
      
          public int f { get { return g + h; } }
          public AStarNode(int x, int y)
          {
              this.x = x;
              this.y = y;
          }
      }
      
      
      public class AStar 
      {
          //f = g + h
          //开放列表
          public HashSet<AStarNode> openList = new HashSet<AStarNode>();
          //关闭列表
          public HashSet<AStarNode> closeList = new HashSet<AStarNode>();
      
          private AStarNode[,] Map = null;
      
          private int MinX,MaxX,MinY,MaxY;
          /// <summary>
          /// 初始化
          /// </summary>
          /// <param name="x"></param>
          /// <param name="y"></param>
          public void Init(int x, int y, HashSet<(int, int)> blockIndex)
          {
              Map = new AStarNode[x, y];
              for (int i = 0; i < x; i++)
              {
                  for (int j = 0; j < y; j++)
                  {
                      AStarNode node = new AStarNode(i, j);
                      Map[i, j] = node;
                      if (blockIndex.Contains((i, j)))
                          node.isObstacle = true;
                  }
              }
              MinX = MinY = 0;
              MaxX = x;
              MaxY = y;
          }
          #region A星部分
          //步骤
          //1.首先将根节点加入到开放列表中
          //2.在开发列表中找出总消耗最低的点 优先级 f -> h 如果当前点为终点则搜索完毕
          //3.搜索当前点八方向上的点 计算g行动消耗 并加入开放列表 如果计算出的行动消耗比原来的消耗低 则更新g
          //4.将八方向上的点（排除不能行走的部分）的父对象设置为当前点
          //5.重复循环2 - 3 - 4 直到找到目标点 或者 没有目标了
          #endregion
      
          #region JPS跳点
          //1.首先将根节点加入到开放列表中
          //2.在开发列表中找出总消耗最低的点 优先级 f -> h 如果当前点为终点则搜索完毕
          //3.搜索上下左右方向依次往前搜索 再其他八方向上搜索
          //3.1 搜索到阻挡格或者是边界时返回
          //3.2 搜索到终点时直接返回结果
          //3.3 搜索到跳点时将跳点的父节点加入到开放列表中（拥有强迫邻居的点为跳点）
          //3.4 更新父节点的行动消耗
          //4. 
          //重复循环2-3-4
          #endregion
      
      
          #region A* 和 jps的区别
          //A ∗算法的邻居节点为几何意义上的邻居，而JPS算法的邻居节点为跳跃所得的邻居。
          #endregion
          public AStarNode IndexToNode((int,int) index)
          {
              return Map[index.Item1, index.Item2];
          }
      
          public List<AStarNode> GetAStar(AStarNode start, AStarNode end)
          {
              AStarNode node = GetAStarLine(start, end);
              if (node != null)
              {
                  List<AStarNode> nodes = new List<AStarNode>();
                  nodes.Add(node);
                  while(node.parent != null)
                  {
                      nodes.Add(node.parent);
                      node = node.parent;
                  }
                  nodes.Reverse();
                  return nodes;
              }
              return null;
          }
      
          private AStarNode GetAStarLine(AStarNode start, AStarNode end)
          {
              openList.Add(start);
      
              AStarNode current = null;
              while (openList.Count > 0)
              {
                  current = null;
                  openList.ForEach((k) =>
                  {
                      if (current == null) current = k;
                      //花费相同的情况下 选择距离终近的
                      if (k.f < current.f || (k.f == current.f && k.h < current.h))
                          current = k;
                  });
      
                  openList.Remove(current);
                  closeList.Add(current);
      
                  if (current == end)
                      break;
      
                  int x = current.x;
                  int y = current.y;
                  for (int i = x - 1; i <= x + 1; i++)
                  {
                      for (int j = y - 1; j <= y + 1; j++)
                      {
                          if (i == 0 && j == 0) continue;
      
                          if (CheckOutSide(i, j))
                              continue;
                          var checkNode = Map[i, j];
      
                          if (checkNode.isObstacle || closeList.Contains(checkNode))
                              continue;
      
      
                          //更新当前点周围的点的行动消耗
                          int newgCost = current.f + GetDistance(current, checkNode);
                          bool inOpenList = openList.Contains(checkNode);
                          //不在开放列表中加入开放列表 如果有更优的行动方式 则更新行动方式
                          if (newgCost < checkNode.g || !inOpenList)
                          {
                              checkNode.g = newgCost;
                              checkNode.h = GetDistance(checkNode, end);
                              checkNode.parent = current;
      
                              if (!inOpenList)
                                  openList.Add(checkNode);
                          }
                      }
                  }
                 
              }
      
              return current;
          }
      
          private int GetDistance(AStarNode current,AStarNode point)
          {
              int distanceX = (int)Mathf.Abs(current.x - point.x);
              int distanceY = (int)Mathf.Abs(current.y - point.y);
              if (distanceX > distanceY)
              {
                  return 14 * (distanceY) + 10 * (distanceX - distanceY);
              }
              else
                  return 14 * (distanceX) + 10 * (distanceY - distanceX);
          }
      
          private bool CheckOutSide(int x,int y)
          {
              if (x < MinX || x > MaxX || y < MinX || y > MaxX)
                  return true;
              return false; 
          }
      
      }
      
      ```

- 进阶JPS算法

  - JPS算法又叫跳点算法，是A* 算法的进阶，因为A*默认会将周围非障碍物点计算花费后加入openlist，这样导致openlist中的点越来越多非常消耗时间，而跳点寻路的优势是只会将跳点加入到openlist中遍历减少了遍历花费的时间。
  - 概念
    - 强迫邻居
      - 当前检测的节点（相对于行进方向）靠边的点为障碍点时那么这个点就是强迫邻居
    - 跳点 满足三个条件之一的就是跳点 ，跳点会被加入到openlist中去计算获取最小带价的点
      - 起点/终点
      - 节点拥有至少一个强迫邻居
      - 
  - 算法

- 根据实际运用使用合适算法